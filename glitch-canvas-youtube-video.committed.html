<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Glitch Canvas YouTube</title>
  <style>
    #suggestedVideo, #suggestedPlaylist, #suggestedVideo2, #suggestedVideo3,
    #ytInput, #startBtn, #randomizeBtn, #autoGlitchBtn, #continualRandomizeBtn,
    #sliderContainer, #wired-btn {
        opacity: 0.2;
        transition: opacity 0.2s ease-in-out;
    }

    #suggestedVideo:hover, #suggestedPlaylist:hover, #suggestedVideo2:hover, #suggestedVideo3:hover,
    #ytInput:hover, #startBtn:hover, #randomizeBtn:hover, #autoGlitchBtn:hover, #continualRandomizeBtn:hover,
    #sliderContainer:hover, #wired-btn:hover {
        opacity: 1;
    }

    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: black;
      transition: transform 0.1s ease-in-out;
      height: 100%; width: 100%;
      cursor: crosshair;
    }
    canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
    }
    #glitchCanvas { z-index: 0; }
    #ytFrame {
      filter: brightness(0.9) contrast(1.1); /* Slightly crush blacks and pop whites for a more analog feel */
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 1;
      border: none;
    }

    @font-face {
      font-family: 'BlackOut 2AM';
      src: url('../fonts/BlackOut-2AM-webfont.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }
  


   #suggestedVideo, #suggestedPlaylist, #suggestedVideo2, #suggestedVideo3 {
      font-family: 'BlackOut 2AM', monospace;
      text-align: center;
      color: white;
      cursor: pointer;
      z-index: 5;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ and Edge */
      user-select: none; /* Standard syntax */
    }

    /*
    /=============================================\
    |                                             |
    |   HERE ARE THE LAYOUT PERCENTAGES FOR THE   |
    |           SUGGESTED VIDEO LINKS             |
    |                                             |
    \=============================================/
    */
    #suggestedVideo {
      top: 5%;
    }

    #suggestedVideo3 {
      top: 10%;
    }

    #suggestedVideo2 {
      top: 15%;
    }

    #suggestedPlaylist {
      top: 20%;
    }

    input, button {
      position: absolute;
      font-family: monospace;
      font-size: 14px;
      padding: 10px 16px;
      color: white;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid white;
      z-index: 5;
      transition: all 0.2s ease-in-out;
    }
    button:active {
      transform: scale(0.95) rotate(-1deg);
      background: rgba(255, 0, 255, 0.3);
      box-shadow: 0 0 8px white;
    }
    #ytInput {
      top: 40%; left: 50%; transform: translate(-50%, -50%);
      width: 320px;
    }
    #startBtn {
      top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    #randomizeBtn { top: 60px; right: 20px; display: none; z-index: 10; }
    #autoGlitchBtn { top: 20px; right: 20px; display: none; z-index: 10; }
    #continualRandomizeBtn { top: 100px; right: 20px; display: none; z-index: 10; width: 230px; }

    /* New slider container */
    #sliderContainer {
      position: absolute;
      top: 70px;
      left: 20px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border: 1px solid white;
      border-radius: 5px;
      display: none; /* Hidden until start */
    }
    .slider-group {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    .slider-group label {
      font-family: monospace;
      font-size: 12px;
      color: white;
      width: 120px; /* Align sliders */
    }
    .slider-group input[type="range"] {
        margin-left: 120px;
    }

    .lock-button {
      font-family: monospace;
      font-size: 11px;
      color: white;
      background: black;
      border: 1px solid white;
      margin-left: 230%;
      cursor: pointer;
      padding: 4px 8px;
    }

    .lock-button.locked {
      color: black;
      background: white;
    }

    /* Notification style */
    .notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 255, 13, 0.8);
      color: black;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 100;
      font-family: monospace;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      pointer-events: none;
    }

    /* --- Wired Button CRT Styles --- */
    .wired-button {
      font-family: 'Courier New', Courier, monospace;
      text-decoration: none;
      color: #00ffff;
      background: rgba(0, 20, 20, 0.5); /* More faded background */
      border: 2px solid #00ffff;
      border-radius: 8px;
      cursor: pointer;
      overflow: hidden; /* Keep scanlines inside */
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 
                  0 0 20px rgba(0, 255, 255, 0.3), 
                  inset 0 0 15px rgba(0, 255, 255, 0.2);
      text-shadow: 0 0 4px #00ffff, 0 0 8px #00ffff;
      animation: crt-flicker 0.2s infinite;
      transition: all 0.2s ease;
    }

    .wired-button:hover {
        background: rgba(0, 40, 40, 0.7);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.8), 
                    0 0 30px rgba(0, 255, 255, 0.5), 
                    inset 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .wired-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.15) 50%, rgba(0,0,0,0.3) 50%);
      background-size: 100% var(--scanline-thickness, 4px);
      opacity: 0.6;
      animation: scanline-move var(--scanline-speed, 4s) linear infinite;
      pointer-events: none;
    }

    #wired-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 15px 30px;
      font-size: 1.5em;
      z-index: 20; /* Ensure it's on top */
    }

    @keyframes crt-flicker {
      0%, 100% { opacity: 0.9; }
      50% { opacity: 1; }
    }

    @keyframes scanline-move {
      from { background-position: 0 0; }
      to { background-position: 0 -8px; } /* Faster movement */
    }

/* --- Preset Dropdown Menu Styles --- */
/* --- Preset Dropdown Menu Styles (inspired by double-oh-six.html) --- */
#preset-toggle-btn {
  position: fixed;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9991; /* Above the dropdown container */
  font-family: 'Share Tech Mono', 'Consolas', monospace;
  font-size: 0.9rem; /* Slimmer */
  padding: 5px 15px; /* Slimmer */
  border-radius: 0 0 8px 8px; /* from preset-toggle-btn */
  font-weight: normal; /* Slimmer */
  cursor: pointer;
  display: none; /* Hidden until playback starts */
  opacity: 0.5;
  overflow: hidden; /* Keep scanlines inside */
  position: relative; /* For scanline pseudo-element */
  color: #00ffff;
  background: rgba(0, 20, 20, 0.5);
  border: 2px solid #00ffff;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 15px rgba(0, 255, 255, 0.2);
  text-shadow: 0 0 4px #00ffff, 0 0 8px #00ffff;
  animation: crt-flicker 0.2s infinite;
  transition: all 0.2s ease;
}

#preset-toggle-btn:hover {
  background: #39ffff;
  box-shadow: 0 2px 15px rgba(0, 255, 247, 0.8);
}

#preset-toggle-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(to bottom, rgba(255,255,255,0.15) 50%, rgba(0,0,0,0.3) 50%);
  background-size: 100% var(--scanline-thickness, 4px);
  opacity: 0.6;
  animation: scanline-move var(--scanline-speed, 4s) linear infinite;
  pointer-events: none;
}

#preset-dropdown-container { /* This is the actual dropdown panel */
  position: fixed;
  top: 0;
  left: 50%; /* Center horizontally */
  transform: translateX(-50%); /* Center horizontally */
  width: 90%; /* Constrain width */
  max-width: 600px; /* Max width to prevent it from being too wide */
  height: 0; /* Initially closed */
  overflow: hidden; /* Keep scanlines inside */
  background-color: rgba(10, 26, 35, 0.5); /* Dark, 50% transparent background */
  border-bottom: 2px solid #00fff7;
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 15px rgba(0, 255, 255, 0.2);
  z-index: 9990; /* Below the toggle button */
  transition: height 0.4s ease-in-out, opacity 0.4s ease-in-out;
  display: none; /* Hidden initially, will be shown by JS */
  flex-direction: column; /* To stack preset-bar and current-preset-display */
  justify-content: center;
  align-items: center;
  padding-top: 30px; /* Adjust for slimmer toggle button */
  box-sizing: border-box;
  opacity: 0; /* Initially hidden for transition */
}

#preset-dropdown-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(to bottom, rgba(255,255,255,0.15) 50%, rgba(0,0,0,0.3) 50%);
  background-size: 100% var(--scanline-thickness, 4px);
  opacity: 0.6;
  animation: scanline-move var(--scanline-speed, 4s) linear infinite; /* Scanline effect */
  pointer-events: none;
}

.preset-bar { 
  display: flex; 
  position: relative; /* Establish a positioning context for absolute children */
  width: 100%;
  height: 100%;
} 
.preset-dropdown, .preset-name-input, .preset-save-btn, .preset-delete-btn, .preset-delete-all-btn, .preset-nav-btn { 
  font-family: 'Share Tech Mono', 'Consolas', monospace; 
  font-size: 0.9rem; /* Slimmer */
  border: 2px solid #00fff7; 
  border-radius: 4px;
  margin: 2px; /* Slimmer */
  padding: 4px 8px; /* Slimmer */
  outline: none; 
  transition: box-shadow 0.2s, border-color 0.2s, background 0.2s, color 0.2s; 
  box-shadow: 0 0 8px rgba(0, 255, 247, 0.6); 
  opacity: 1; /* Controls are now fully opaque, but their background is transparent */
  position: absolute; /* Use absolute positioning for precise control */
  color: #00fff7;
  background: rgba(16, 28, 34, 0.5);
  cursor: pointer;
} 


 
.preset-dropdown:focus, .preset-name-input:focus, .preset-save-btn:focus, .preset-delete-btn:focus, .preset-delete-all-btn:focus, .preset-nav-btn:focus { 
  border-color: #fff; 
  box-shadow: 0 0 12px #00fff7cc; 
  opacity: 1; 
} 
 
.preset-save-btn { 
  cursor: pointer; 
  font-weight: bold;
  right: 0; /* Aligned to the far right */
  top: 0px;
  transform: translateX(0%); /* Adjust position with transform */
} 

.preset-delete-btn {
  cursor: pointer; 
  font-weight: bold;
  right: 5%; /* Aligned to the right */
  top: 32px;
  transform: translateX(5%); /* Adjust position with transform */
  background: rgba(34, 16, 16, 0.5);
  color: #ff2a2a;
  border-color: #ff2a2a;
}

.preset-delete-all-btn {
  cursor: pointer;
  font-weight: bold;
  right: 0; /* Aligned to the far right */
  top: 32px;
  transform: translateX(0%);
  background: rgba(255, 0, 255, 0.5); /* Magenta */
  color: #ffffff;
  border-color: #ff00ff;
}
 
.preset-nav-btn { 
  width: 28px; /* Slimmer */
  height: 28px; /* Slimmer */
  background: #101c22; 
  color: #00fff7; 
  border: 2px solid #00fff7; 
  border-radius: 50%; 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  font-size: 1rem; /* Slimmer */
  cursor: pointer;
  box-shadow: 0 0 8px #00fff799;
} 

.preset-nav-btn.left {
  top: 30px;
  left: calc(50% - 150px); /* 150px to the left of center */
  transform: translateX(-50%);
}

.preset-nav-btn.right {
  top: 30px;
  left: calc(50% + 150px); /* 150px to the right of center */
  transform: translateX(-50%);
}
.preset-dropdown {
  top: 0px; left: 66%; transform: translateX(-66%);
} 

.preset-nav-btn:hover {
  background: #00fff7; 
  color: #101c22; 
  border-color: #fff; 
}

.preset-save-btn:hover, .preset-delete-btn:hover {
  background: #00fff7;
  color: #101c22;
  border-color: #fff;
}

.preset-delete-btn:hover {
    background: #ff2a2a;
    color: white;
}

.preset-delete-all-btn:hover {
    background: #ff00ff;
    color: black;
}

.current-preset-display {
  position: absolute; /* Position relative to the container */
  top: 35px; /* Position from the top of the container */
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Courier New', Times, serif;
  color: crimson;
  text-shadow: 0 0 5px rgb(127, 255, 246);
  pointer-events: none;
  font-size: 1.15rem;
  text-align: center;
  /* display: none; */ /* Hidden by default - REMOVED FOR DEBUGGING */
  z-index: 1; /* On top of other elements in the container */
  opacity: 1;
}


  </style>
</head>
<body>
  <button id="preset-toggle-btn">Show Presets</button>
  <div id="preset-dropdown-container"> <!-- This is the actual dropdown panel -->
    <div class="preset-bar" id="preset-bar"> <!-- This will be the single row of controls -->
      <div class="current-preset-display" id="current-preset-display">[DEBUG TEXT]</div>
      <input class="preset-name-input" type="text" placeholder="Preset name…" maxlength="32"/>
      <button class="preset-nav-btn left" title="Previous preset">◀</button>
      <select class="preset-dropdown"></select>
      <button class="preset-nav-btn right" title="Next preset">▶</button>
      <button class="preset-save-btn">Save</button>
      <button class="preset-delete-btn">Delete</button>
      <button class="preset-delete-all-btn">ALL</button>
    </div>
  </div>


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NTXL35MFPT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NTXL35MFPT');
</script>

<h2 id="suggestedVideo">SUGGESTED VIDEO : https://www.youtube.com/watch?v=gopYmb38DgM</h2>
<h2 id="suggestedVideo3">SUGGESTED LINK : https://youtu.be/9R1die4Hsw0?si=kgiKXhe_4I-6MAeL</h2>
<h2 id="suggestedVideo2">SUGGESTED *.* : https://www.youtube.com/watch?v=8o6bdTOhIyE</h2>
<h2 id="suggestedPlaylist">SUGGESTED PLAYLIST : https://www.youtube.com/watch?v=RgFaK6ZQifE&list=RDEMWUbu7UjvrEYUSE4m8ATOcw&start_radio=1</h2>
<div id="effects-wrapper">
<iframe id="ytFrame" allow="autoplay; encrypted-media" allowfullscreen></iframe>
<canvas id="glitchCanvas"></canvas>
</div>
<a href="/index.html" id="wired-btn" class="wired-button"><strong>&lt;-WIRED</strong></a>

<input id="ytInput" type="text" placeholder="Paste YouTube Link Here" />
<button id="startBtn">Start and Play</button>
<button id="randomizeBtn" class="wired-button">Randomize</button>
<button id="autoGlitchBtn" class="wired-button">Auto Glitch: OFF</button>
<button id="continualRandomizeBtn" class="wired-button">Continual Randomization: OFF</button>

<!-- Container for individual alpha sliders -->
<div id="sliderContainer">
  <div class="slider-group">
    <label for="randomSeedSlider">Random:</label>
    <input type="range" min="0" max="1" step="0.001" value="0" id="randomSeedSlider">
  </div>
  <!-- Sliders will be dynamically generated here -->
</div>

<script>
const glitchCanvas = document.getElementById('glitchCanvas');
const gctx = glitchCanvas.getContext('2d');
const ytFrame = document.getElementById('ytFrame');
const ytInput = document.getElementById('ytInput');
const startBtn = document.getElementById('startBtn');
const randomizeBtn = document.getElementById('randomizeBtn');
const autoGlitchBtn = document.getElementById('autoGlitchBtn');
const continualRandomizeBtn = document.getElementById('continualRandomizeBtn');
const randomSeedSlider = document.getElementById('randomSeedSlider');
const sliderContainer = document.getElementById('sliderContainer');
const suggestedVideo = document.getElementById('suggestedVideo');
const suggestedPlaylist = document.getElementById('suggestedPlaylist');
const suggestedVideo3 = document.getElementById('suggestedVideo3');
const suggestedVideo2 = document.getElementById('suggestedVideo2');

let autoGlitch = false;
let autoGlitchInterval = null;
let isContinuallyRandomizing = false;
let randomTargetAlphas = {};
const randomizationSpeed = 0.0175; // Lower is slower/smoother
let masterBeat = 0;

function createSeededRandom(seed) {
  return function() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };
}
let lastFrameTime = performance.now();
let customTime = 0;
let timeScale = 1.0;
let masterOpacity = 1.0;
let activeEffects = [];
let isLooping = false;

function resize() {
  glitchCanvas.width = window.innerWidth;
  glitchCanvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

function createTimedEffect(fn, duration = 3000 + Math.random() * 3000) {
  const startTime = performance.now();
  let timedEffect; 
  timedEffect = function() {
    const elapsed = performance.now() - startTime;
    if (elapsed > duration) {
      const index = activeEffects.indexOf(timedEffect);
      if (index > -1) activeEffects.splice(index, 1);
      return;
    }
    fn();
  };
  return timedEffect;
}

function createPersistentEffect(fn) {
  return function() {
    fn();
  };
}

function glitchASCIIArtOverlayFactory(getStrength, isPersistent = false) {
  const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;\\:\'"<>,./?`~ ';
  const cyrillic = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя';
  const greek = 'ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψω';
  const katakana = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
  const hebrew = 'אבגדהוזחטיכךלמםנןסעפףצץקרשת';
  const arabic = 'أبتثجحخدذرزسشصضطظعغفقكلمنهوي';
  const devanagari = 'अआइईउऊऋएऐओऔकखगघङचछजझञटठडढणतथदधनपफबभमयरलवशषसह';
  const thai = 'กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรลวศษสหฬอฮ';
  const hangul = 'ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣ';
  const hanzi = '的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分';
  const symbols = '░▒▓█─│┌┐└┘├┤┬┴┼═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬';
  const superscript = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´≡±‗¾¶§÷¸°¨·¹³²■ñÑ@¿?¡!:/\\áéíóúÁÉÍÓÚäëïöüÄËÏÖÜ½¼¾¹³²ƒ±×÷$£¥¢¤®©ªº°"\'()[]{}«»';
  const chars = (latin + cyrillic + greek + katakana + hebrew + arabic + devanagari + thai + hangul + hanzi + symbols + superscript).split('');
  const renderFn = () => {
    const strength = getStrength();
    const spacing = 10 + (1 - strength) * 20;
    if (strength <= 0) return;
    gctx.save();
    gctx.font = `bold ${spacing + (Math.random() - 0.5) * strength * 1.5}px monospace`;
    gctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 70%, ${0.8 * strength})`;
    gctx.globalCompositeOperation = 'difference';
    for (let y = 0; y < glitchCanvas.height; y += spacing) {
      for (let x = 0; x < glitchCanvas.width; x += spacing) {
        if (Math.random() < 0.5) {
            const char = chars[Math.floor(Math.random() * chars.length)];
            gctx.fillText(char, x, y);
        }
      }
    }
    gctx.restore();
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchFontBurnFactory(getStrength, isPersistent = false) {
  const phrases = ["GL1TCH", "BURN", "DATA", "CORRUPT", "X///Z", "SIGNAL"];
  const renderFn = () => {
    const strength = getStrength();
    if (strength <= 0) return;
    const text = phrases[Math.floor(Math.random() * phrases.length)];
    gctx.save();
    gctx.font = `${10 + Math.random() * 80 * strength}px 'BlackOut 2AM', monospace`;

    // --- Enhanced Hue/Color Cycle Logic ---
    const hueCycleStrength = effectAlphas['Hue/Color Cycle'] ?? 0;
    let fillHue, fillSaturation, fillLightness;
    let shadowHue, shadowSaturation, shadowLightness;
    let blurAmount;
    let compositeOperation = 'lighter'; // Default composite operation

    const blackAndWhiteThreshold = 0.05; // 5% at each end for B&W

    if (hueCycleStrength < blackAndWhiteThreshold) { // Black text
        fillLightness = 0;
        shadowLightness = 100;
        fillSaturation = shadowSaturation = 0;
        fillHue = shadowHue = 0;
        blurAmount = 2 + strength * 5; // Sharper
        compositeOperation = 'multiply'; // Use multiply for pure black text
    } else if (hueCycleStrength > 1 - blackAndWhiteThreshold) { // White text
        fillLightness = 100;
        shadowLightness = 0;
        fillSaturation = shadowSaturation = 0;
        fillHue = shadowHue = 0;
        blurAmount = 2 + strength * 5; // Sharper
    } else { // Color text
        const colorRange = 1 - (blackAndWhiteThreshold * 2);
        const colorProgress = (hueCycleStrength - blackAndWhiteThreshold) / colorRange;
        fillHue = colorProgress * 360;
        shadowHue = (fillHue + 180) % 360; // Inverse hue for shadow
        fillSaturation = shadowSaturation = 100;
        fillLightness = shadowLightness = 50;
        blurAmount = 5 + strength * 25; // More blurred
    }

    gctx.fillStyle = `hsla(${fillHue}, ${fillSaturation}%, ${fillLightness}%, ${0.8 * strength})`;
    gctx.shadowColor = `hsla(${shadowHue}, ${shadowSaturation}%, ${shadowLightness}%, 1)`;
    gctx.shadowBlur = blurAmount;
    gctx.globalCompositeOperation = compositeOperation;
    const x = Math.random() * glitchCanvas.width;
    const y = Math.random() * glitchCanvas.height;
    gctx.fillText(text, x, y);
    gctx.restore();    
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchNeonGradientOverlayFactory(getStrength, isPersistent = false) {
  const numColors = 5;
  const colors = [];
  const baseHue = Math.random() * 360;
  for (let i = 0; i < numColors; i++) {
    colors.push({
      hue: (baseHue + i * (360 / numColors)) % 360,
      stop: i / (numColors - 1)
    });
  }
  const renderFn = () => {
    const strength = getStrength();
    const alpha = strength;
    if (strength <= 0) return;
    const x = glitchCanvas.width * (0.5 + (Math.random() - 0.5) * masterBeat * 0.5);
    const y = glitchCanvas.height * (0.5 + (Math.random() - 0.5) * masterBeat * 0.5);
    const radius = (glitchCanvas.width / 4) + (masterBeat * (glitchCanvas.width / 3)) * strength;
    const gradient = gctx.createRadialGradient(x, y, 0, x, y, radius);
    const hueShift = masterBeat * 40;
    colors.forEach(color => {
        gradient.addColorStop(color.stop, `hsla(${(color.hue + hueShift) % 360}, 100%, 70%, ${0.6 * alpha})`);
    });
    gctx.save();
    gctx.globalCompositeOperation = 'screen';
    gctx.fillStyle = gradient;
    gctx.fillRect(0, 0, glitchCanvas.width, glitchCanvas.height);
    gctx.restore();    
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchScanlinesFactory(getStrength, isPersistent = false) {
  const renderFn = () => {
    const strength = getStrength();
    // Non-existent at minimum level
    if (strength <= 0) return;

    // More prominent at peak level
    const yOffset = masterBeat * 6 * strength; // Slightly faster scroll
    const lineHeight = 1 + Math.floor(strength * 5); // Thicker lines at max strength (up to 6px)
    gctx.save();
    gctx.globalAlpha = 0.75 * strength; // More opaque at max strength
    gctx.fillStyle = `hsla(0, 0%, 10%, 0.8)`; // Dark, consistent color for a classic look
    for (let y = yOffset % (lineHeight * 2); y < glitchCanvas.height; y += (lineHeight * 2)) {
      gctx.fillRect(0, y, glitchCanvas.width, lineHeight);
    }
    gctx.restore();
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}



function glitchVHSFactory(getStrength, isPersistent = false) {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  const renderFn = () => {
    const strength = getStrength();
    if (strength <= 0) return;
    const w = glitchCanvas.width;
    const h = glitchCanvas.height;
    tempCanvas.width = w;
    tempCanvas.height = h;
    tempCtx.drawImage(glitchCanvas, 0, 0);
    gctx.clearRect(0, 0, w, h);
    const wobbleAmount = strength * 15;
    const rollSpeed = customTime / 500;
    const sliceHeight = 5;
    for (let y = 0; y < h; y += sliceHeight) {
      const wobbleOffset = Math.sin(y / 30 + rollSpeed) * wobbleAmount;
      gctx.drawImage(tempCanvas, 0, y, w, sliceHeight, wobbleOffset, y, w, sliceHeight);
    }
    gctx.save();
    gctx.globalCompositeOperation = 'overlay';
    gctx.globalAlpha = strength * 0.2;
    for (let i = 0; i < 100 * strength; i++) {
      const x = Math.random() * w;
      const y = (Math.random() * h + customTime / 10) % h;
      const size = Math.random() * 2;
      gctx.fillStyle = `hsla(0, 0%, 100%, ${Math.random() * 0.5})`;
      gctx.fillRect(x, y, size, size);
    }
    gctx.restore();
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchBrightFlashFactory(getStrength, isPersistent = false) {
  const renderFn = () => {
    const strength = getStrength();
    if (strength <= 0) return;
    gctx.save();
    gctx.globalAlpha = (0.1 + Math.random() * 0.25) * strength;
    gctx.fillStyle = `hsl(${Math.random() * 360}, 90%, 90%)`;
    gctx.fillRect(0, 0, glitchCanvas.width, glitchCanvas.height);
    gctx.restore();    
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchHSLRainbowFactory(getStrength, isPersistent = false) {
  const start = performance.now();
  const renderFn = () => {
    const strength = getStrength();
    if (strength <= 0) return;
    const time = (customTime - start) * 0.002;
    gctx.save();
    gctx.globalCompositeOperation = 'difference';
    gctx.globalAlpha = strength * 0.7;
    gctx.fillStyle = `hsl(${(time * 90) % 360}, 100%, 50%)`;
    gctx.fillRect(0, 0, glitchCanvas.width, glitchCanvas.height);
    gctx.restore();    
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchStrobeFactory(getStrength, isPersistent = false) {
    const renderFn = () => {
        const strength = getStrength();
        gctx.save();
        gctx.globalAlpha = Math.random() < (strength * 0.5 * timeScale) ? strength * 0.5 : 0;
        gctx.fillStyle = `hsl(${Math.random() * 360}, 90%, 90%)`;
        gctx.fillRect(0, 0, glitchCanvas.width, glitchCanvas.height);
        gctx.restore();
    };
    return isPersistent ? renderFn : createTimedEffect(renderFn);
}

function glitchGeminiBombFactory(getStrength, isPersistent = false) {
  const possibleShapes = ['rect', 'circle', 'triangle', 'star', 'cross'];
  const possiblePatterns = ['solid', 'striped-h', 'striped-v'];
  const numShapes = 2 + Math.floor(Math.random() * 20 * getStrength());
  const shapes = [];
  for (let i = 0; i < numShapes; i++) {
    shapes.push({
      x: glitchCanvas.width * 0.5,
      y: glitchCanvas.height * 0.5,
      baseSize: 5 + Math.random() * 15,
      shapeType: possibleShapes[Math.floor(Math.random() * possibleShapes.length)],
      pattern: possiblePatterns[Math.floor(Math.random() * possiblePatterns.length)],
      angle: Math.random() * Math.PI * 2,
      speed: (1 + Math.random() * 8),
      hue: Math.random() * 360,
    });
  }
  const renderFn = () => {
    const strength = getStrength();
    if (strength <= 0) return;
    gctx.save();
    gctx.globalCompositeOperation = 'lighter';
    shapes.forEach(shape => {
      const moveDistance = shape.speed * strength * timeScale;
      shape.x += Math.cos(shape.angle) * moveDistance;
      shape.y += Math.sin(shape.angle) * moveDistance;
      const currentSize = (shape.baseSize + masterBeat * 10) * strength;
      if (!isPersistent) {
        shape.speed *= 0.99;
      } else {
        if (shape.x < 0 || shape.x > glitchCanvas.width || shape.y < 0 || shape.y > glitchCanvas.height) {
            shape.x = glitchCanvas.width * 0.5;
            shape.y = glitchCanvas.height * 0.5;
            shape.angle = Math.random() * Math.PI * 2;
            shape.speed = (1 + Math.random() * 8);
        }
      }

      gctx.fillStyle = `hsla(${shape.hue}, 100%, 70%, ${0.75 * strength})`;
      gctx.strokeStyle = `hsla(${shape.hue}, 100%, 70%, ${0.75 * strength})`;
      gctx.lineWidth = 1;

      gctx.save();
      gctx.beginPath();

      if (shape.shapeType === 'rect') {
        gctx.rect(shape.x - currentSize / 2, shape.y - currentSize / 2, currentSize, currentSize);
      } else if (shape.shapeType === 'circle') {
        gctx.arc(shape.x, shape.y, currentSize / 2, 0, Math.PI * 2);
      } else if (shape.shapeType === 'triangle') {
        const angleOffset = Math.PI / 2;
        gctx.moveTo(shape.x + currentSize / 2 * Math.cos(angleOffset), shape.y + currentSize / 2 * Math.sin(angleOffset));
        gctx.lineTo(shape.x + currentSize / 2 * Math.cos(angleOffset + 2 * Math.PI / 3), shape.y + currentSize / 2 * Math.sin(angleOffset + 2 * Math.PI / 3));
        gctx.lineTo(shape.x + currentSize / 2 * Math.cos(angleOffset + 4 * Math.PI / 3), shape.y + currentSize / 2 * Math.sin(angleOffset + 4 * Math.PI / 3));
      } else if (shape.shapeType === 'star') {
        const spikes = 5;
        const outerRadius = currentSize / 2;
        const innerRadius = outerRadius / 2.5;
        let rot = Math.PI / 2 * 3;
        let x = shape.x;
        let y = shape.y;
        let step = Math.PI / spikes;
        gctx.moveTo(shape.x, shape.y - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = shape.x + Math.cos(rot) * outerRadius;
            y = shape.y + Math.sin(rot) * outerRadius;
            gctx.lineTo(x, y);
            rot += step;
            x = shape.x + Math.cos(rot) * innerRadius;
            y = shape.y + Math.sin(rot) * innerRadius;
            gctx.lineTo(x, y);
            rot += step;
        }
        gctx.lineTo(shape.x, shape.y - outerRadius);
      } else if (shape.shapeType === 'cross') {
          const armWidth = currentSize / 3;
          // These two rects will form two sub-paths.
          gctx.rect(shape.x - armWidth / 2, shape.y - currentSize / 2, armWidth, currentSize);
          gctx.rect(shape.x - currentSize / 2, shape.y - armWidth / 2, currentSize, armWidth);
      }
      gctx.closePath();

      if (shape.pattern === 'solid') {
        gctx.fill();
      } else if (shape.pattern === 'striped-h' || shape.pattern === 'striped-v') {
        gctx.clip(); // Clip to the path defined above
        const isVertical = shape.pattern === 'striped-v';
        const stripeSpacing = 4;
        const bounds = { // Use a slightly larger bounding box to ensure stripes cover the whole shape
            x1: shape.x - currentSize / 2 - stripeSpacing,
            y1: shape.y - currentSize / 2 - stripeSpacing,
            x2: shape.x + currentSize / 2 + stripeSpacing,
            y2: shape.y + currentSize / 2 + stripeSpacing,
        };
        gctx.beginPath(); // Start a new path for the stripes
        if (isVertical) {
            for (let x = bounds.x1; x < bounds.x2; x += stripeSpacing) {
                gctx.moveTo(x, bounds.y1);
                gctx.lineTo(x, bounds.y2);
            }
        } else {
            for (let y = bounds.y1; y < bounds.y2; y += stripeSpacing) {
                gctx.moveTo(bounds.x1, y);
                gctx.lineTo(bounds.x2, y);
            }
        }
        gctx.stroke();
      }
      gctx.restore();
    });
    gctx.restore();    
  };
  return isPersistent ? renderFn : createTimedEffect(renderFn);
}



const timedEffectsDefs = [
  { name: 'Neon Grad', factory: glitchNeonGradientOverlayFactory, defaultAlpha: 0.5 },
  { name: 'Scanlines', factory: glitchScanlinesFactory, defaultAlpha: 0.4 },
  { name: 'Flash', factory: glitchBrightFlashFactory, defaultAlpha: 0.8 },
  { name: 'HSL Rainbow', factory: glitchHSLRainbowFactory, defaultAlpha: 0.6 },
  { name: 'ASCII', factory: glitchASCIIArtOverlayFactory, defaultAlpha: 0.7 },
  { name: 'Font Burn', factory: glitchFontBurnFactory, defaultAlpha: 1.0 },
  { name: 'Strobe', factory: glitchStrobeFactory, defaultAlpha: 1.0 },
  { name: 'Gemini Bomb', factory: glitchGeminiBombFactory, defaultAlpha: 0.9 },
  { name: 'Data Bands', factory: glitchVHSFactory, defaultAlpha: 0.0 },
];
const masterEffectsDefs = [
    { name: 'B&W Invert', defaultAlpha: 0.0 },
    { name: 'Hue/Color Cycle', defaultAlpha: 0.0 }
];
const instantEffectsDefs = [];
const dataBombDef = { name: 'Data Bomb', defaultAlpha: 0.0 };
const allEffectDefinitions = [...timedEffectsDefs, ...instantEffectsDefs, dataBombDef];
const effectAlphas = {};
const sliderElements = {};
const sliderLocks = {}; // Object to store lock states

function applyMasterFilters() {
    const wrapper = document.getElementById('effects-wrapper');
    const filters = [];

    // B&W Invert Logic
    const bwStrength = (effectAlphas['B&W Invert'] ?? 0) * masterOpacity;
    if (bwStrength > 0.01) {
        let grayscale = Math.min(1, bwStrength * 2);
        let invertValue = 0;
        if (bwStrength > 0.5) {
            invertValue = (bwStrength - 0.5) * 2;
        }
        filters.push(`grayscale(${grayscale}) invert(${invertValue})`);
    }

    // Hue/Color Cycle Logic
    const hueStrength = (effectAlphas['Hue/Color Cycle'] ?? 0) * masterOpacity;
    if (hueStrength > 0.01) {
        const angle = hueStrength * 360;
        filters.push(`hue-rotate(${angle}deg)`);
    }

    if (filters.length > 0) {
        wrapper.style.filter = filters.join(' ');
    } else {
        wrapper.style.filter = 'none';
    }
}

const globalGroup = document.createElement('div');
globalGroup.className = 'slider-group';
const globalLabel = document.createElement('label');
globalLabel.textContent = `Global Opacity:`;
const globalSlider = document.createElement('input');
globalSlider.type = 'range';
globalSlider.min = 0;
globalSlider.max = 1;
globalSlider.step = 0.01;
globalSlider.value = masterOpacity;
globalSlider.addEventListener('input', () => {
  masterOpacity = parseFloat(globalSlider.value);
});
globalGroup.appendChild(globalLabel);
globalGroup.appendChild(globalSlider);
sliderContainer.appendChild(globalGroup);

([...timedEffectsDefs, ...instantEffectsDefs, dataBombDef, ...masterEffectsDefs]).sort((a, b) => a.name.localeCompare(b.name)).forEach(def => {
  effectAlphas[def.name] = def.defaultAlpha;
  sliderLocks[def.name] = false; // Initialize all as unlocked

  const group = document.createElement('div');
  group.className = 'slider-group';
  const label = document.createElement('label');
  label.textContent = `${def.name}:`;
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = 0;
  slider.max = 1;
  slider.step = 0.01;
  slider.value = def.defaultAlpha;
  sliderElements[def.name] = slider;
  slider.addEventListener('input', () => {
    effectAlphas[def.name] = parseFloat(slider.value);
  });

  if (def.name === 'Scanlines') {
    slider.addEventListener('input', (e) => {
      const strength = parseFloat(e.target.value);
      // Map strength (0-1) to scanline thickness (1px - 15px)
      const thickness = 1 + strength * 14;
      // Map strength (0-1) to animation speed (8s - 0.5s), inverted
      const speed = 8 - strength * 7.5;
      document.body.style.setProperty('--scanline-thickness', `${thickness}px`);
      document.body.style.setProperty('--scanline-speed', `${speed}s`);
    });
  }

  group.appendChild(label);
  group.appendChild(slider);
  
    // Add Lock Button
    const lockButton = document.createElement('button');
    lockButton.className = 'lock-button';
    lockButton.textContent = '<LOCK!>';
    lockButton.addEventListener('click', () => {
        sliderLocks[def.name] = !sliderLocks[def.name]; // Toggle lock state
        lockButton.classList.toggle('locked', sliderLocks[def.name]);
        lockButton.textContent = sliderLocks[def.name] ? '[LOCKED!]' : '<LOCK!>';
    });

    group.appendChild(lockButton);
  
  sliderContainer.appendChild(group);
});

function generateNewRandomTargets() {
  Object.keys(effectAlphas).forEach(name => {
    if (!sliderLocks[name]) {
        randomTargetAlphas[name] = Math.random();
    }
  });
  // Also randomize the global opacity
  randomTargetAlphas['global'] = Math.random();
}

randomizeBtn.addEventListener('click', () => {
    // Global opacity is not lockable, so it always randomizes
    const randomGlobalOpacity = Math.random();
    masterOpacity = randomGlobalOpacity;
    globalSlider.value = randomGlobalOpacity;

    Object.keys(effectAlphas).forEach(effectName => {
        if (!sliderLocks[effectName]) { // Only randomize if not locked
            const randomValue = Math.random();
            effectAlphas[effectName] = randomValue;
            sliderElements[effectName].value = randomValue;
        }
    });
});

continualRandomizeBtn.addEventListener('click', () => {
  isContinuallyRandomizing = !isContinuallyRandomizing;
  continualRandomizeBtn.textContent = isContinuallyRandomizing ? 'Continual Randomization: ON' : 'Continual Randomization: OFF';
  if (isContinuallyRandomizing) {
    generateNewRandomTargets();
  }
});


let isAutoGlitching = false;
function persistentAutoGlitchLoop() {
  activeEffects = []; // Always clear effects for a clean state
  if (isAutoGlitching) {
    timedEffectsDefs.forEach(def => {
      const getStrength = () => effectAlphas[def.name] * masterOpacity;
      const persistentEffectFn = def.factory(getStrength, true);
      activeEffects.push(persistentEffectFn);
    });
  }
}

autoGlitchBtn.addEventListener('click', () => {
  isAutoGlitching = !isAutoGlitching;
  autoGlitchBtn.textContent = isAutoGlitching ? 'Auto Glitch: ON' : 'Auto Glitch: OFF';
  persistentAutoGlitchLoop();
});

function mainRenderLoop() {
  isLooping = true;
  const now = performance.now();
  const deltaTime = now - lastFrameTime;
  lastFrameTime = now;
  const dataBombStrength = effectAlphas['Data Bomb'] * masterOpacity;
  const maxSpeed = 2.0;
  const minSpeed = 0.1;
  timeScale = maxSpeed - (dataBombStrength * (maxSpeed - minSpeed));
  customTime += deltaTime * timeScale;
  masterBeat = (Math.sin(customTime / 200) + 1) / 2;
  gctx.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);
  activeEffects.forEach(fn => fn());

  if (isContinuallyRandomizing) {
        // --- New Continual Randomization Logic ---
        // This logic moves each slider at a constant speed towards its target.
        // When a target is reached, a new one is generated for that specific slider,
        // ensuring perpetual, non-diminishing motion.

        // Handle Global Opacity
        const globalTarget = randomTargetAlphas['global'];
        const globalDiff = globalTarget - masterOpacity;
        if (Math.abs(globalDiff) < randomizationSpeed) {
            randomTargetAlphas['global'] = Math.random(); // Get new target
        } else {
            masterOpacity += Math.sign(globalDiff) * randomizationSpeed;
            globalSlider.value = masterOpacity;
        }

        // Handle all other effect sliders
        Object.keys(effectAlphas).forEach(key => {
            if (!sliderLocks[key]) { // Only randomize if not locked
                const target = randomTargetAlphas[key];
                const diff = target - effectAlphas[key];
                if (Math.abs(diff) < randomizationSpeed) {
                    randomTargetAlphas[key] = Math.random(); // Get new target
                } else {
                    effectAlphas[key] += Math.sign(diff) * randomizationSpeed;
                    sliderElements[key].value = effectAlphas[key];
                }
            }
        });
  }
  applyMasterFilters();
  requestAnimationFrame(mainRenderLoop);
}

function startPlayback(url) {
    const playlistMatch = url.match(/[?&]list=([a-zA-Z0-9_-]+)/);
    const videoMatch = url.match(/(?:youtube\.com.*[?&]v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
    let embedUrl = '';

    if (playlistMatch) {
        const playlistId = playlistMatch[1];
        embedUrl = `https://www.youtube.com/embed/videoseries?list=${playlistId}&autoplay=1&controls=0&mute=0&enablejsapi=1`;
    } else if (videoMatch) {
        const videoId = videoMatch[1];
        embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&controls=0&mute=0&enablejsapi=1`;
    }

    if (embedUrl) {
        ytFrame.src = embedUrl;
        ytInput.style.display = 'none';
        startBtn.style.display = 'none';
        suggestedVideo.style.display = 'none';
        suggestedPlaylist.style.display = 'none';
        suggestedVideo3.style.display = 'none';
        suggestedVideo2.style.display = 'none';
        randomizeBtn.style.display = 'block';
        autoGlitchBtn.style.display = 'block';
        continualRandomizeBtn.style.display = 'block';
        sliderContainer.style.display = 'block';
        document.getElementById('preset-toggle-btn').style.display = 'block';
        glitchCanvas.style.zIndex = '2';
        if (!isLooping) {
            mainRenderLoop();
        }
    } else {
        alert('Please enter a valid YouTube video or playlist URL');
    }
}

function copyAndNotify(url) {
    navigator.clipboard.writeText(url).then(() => {
        let notification = document.querySelector('.notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.className = 'notification';
            document.body.appendChild(notification);
        }
        notification.textContent = 'Copied to clipboard';
        notification.style.opacity = '1';
        setTimeout(() => {
            notification.style.opacity = '0';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy text: ', err);
    });
}

startBtn.addEventListener('click', () => {
    startPlayback(ytInput.value.trim());
});

suggestedVideo.addEventListener('click', () => {
    const url = 'https://www.youtube.com/watch?v=gopYmb38DgM';
    copyAndNotify(url);
    startPlayback(url);
});

suggestedVideo2.addEventListener('click', () => {
    const url = 'https://www.youtube.com/watch?v=8o6bdTOhIyE';
    copyAndNotify(url);
    startPlayback(url);
});

suggestedVideo3.addEventListener('click', () => {
    const url = 'https://youtu.be/9R1die4Hsw0?si=kgiKXhe_4I-6MAeL';
    copyAndNotify(url);
    startPlayback(url);
});

suggestedPlaylist.addEventListener('click', () => {
    const url = 'https://www.youtube.com/watch?v=RgFaK6ZQifE&list=RDEMWUbu7UjvrEYUSE4m8ATOcw&start_radio=1';
    copyAndNotify(url);
    startPlayback(url);
});

randomSeedSlider.addEventListener('input', () => {
    const seed = parseFloat(randomSeedSlider.value);
    const seededRandom = createSeededRandom(seed);

    // Set the animation timeline to a random point ("time slice")
    customTime = seededRandom() * 86400000; // Random time within a 24-hour equivalent in ms

    // Set global opacity (not lockable)
    const randomGlobalOpacity = seededRandom();
    masterOpacity = randomGlobalOpacity;
    globalSlider.value = randomGlobalOpacity;

    // Set effect alphas for all sliders based on the seed ("script point")
    Object.keys(effectAlphas).forEach(effectName => {
        if (!sliderLocks[effectName]) { // Only randomize if not locked
            const randomValue = seededRandom();
            effectAlphas[effectName] = randomValue;
            if (sliderElements[effectName]) {
                sliderElements[effectName].value = randomValue;
            }
        }
    });

    // The "script burst" logic that was here has been removed as requested.
});

document.addEventListener('DOMContentLoaded', () => {
    const hiddenUrl = 'https://www.youtube.com/watch?v=DmStNF35o1w';
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    let idleTimer = null;
    let easterEggHasRun = false;

    const flashText = async (text, color, shadowColor, duration) => {
        const numWarnings = 10; // Create 10 instances of the text
        const warnings = []; // Array to hold the created elements

        for (let i = 0; i < numWarnings; i++) {
            const warning = document.createElement('div');
            warning.textContent = text;
            warning.style.position = 'fixed';
            // Random position across the viewport
            warning.style.top = `${Math.random() * 90}vh`;
            warning.style.left = `${Math.random() * 90}vw`;
            // Random size
            warning.style.fontSize = `${Math.random() * 10 + 5}vw`; // font size from 5vw to 15vw
            warning.style.color = color;
            warning.style.zIndex = '9999';
            warning.style.textShadow = `0 0 20px ${shadowColor}`;
            warning.style.pointerEvents = 'none';
            warning.style.transition = 'opacity 0.1s ease-in-out';
            warning.style.opacity = '1';
            document.body.appendChild(warning);
            warnings.push(warning);
        }

        const fonts = ['Courier New', 'monospace', 'Arial Black', 'Impact', 'Georgia', 'Times New Roman', 'Verdana'];
        const intervalTime = 50;
        let elapsed = 0;
        const fontInterval = setInterval(() => {
            warnings.forEach(warning => {
                warning.style.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];
            });
            elapsed += intervalTime;
            if (elapsed >= duration) {
                clearInterval(fontInterval);
            }
        }, intervalTime);

        await sleep(duration);

        warnings.forEach(warning => {
            warning.style.opacity = '0';
        });

        await sleep(100);

        warnings.forEach(warning => {
            if (document.body.contains(warning)) {
                document.body.removeChild(warning);
            }
        });
    };

    const runEasterEgg = async () => {
        if (easterEggHasRun) return;
        easterEggHasRun = true;

        // Clean up listeners to prevent them from running again
        window.removeEventListener('mousemove', resetIdleTimer);
        window.removeEventListener('keydown', resetIdleTimer);
        window.removeEventListener('scroll', resetIdleTimer);
        window.removeEventListener('click', resetIdleTimer);
        clearTimeout(idleTimer);

        if (navigator.clipboard && window.isSecureContext) {
            try {
                await navigator.clipboard.writeText(hiddenUrl);

                // 1. Pre-flash
                await flashText('DATA..', 'crimson', 'red', 400);

                // 2. Green "!"
                const exclamation = document.createElement('div');
                exclamation.textContent = '!';
                exclamation.style.position = 'fixed';
                exclamation.style.top = '50%';
                exclamation.style.left = '50%';
                exclamation.style.transform = 'translate(-50%, -50%)';
                exclamation.style.fontSize = '30vw';
                exclamation.style.color = 'lime';
                exclamation.style.zIndex = '9999';
                exclamation.style.textShadow = '0 0 20px green';
                exclamation.style.pointerEvents = 'none';
                exclamation.style.transition = 'opacity 0.5s ease-in-out';
                exclamation.style.opacity = '1';
                document.body.appendChild(exclamation);

                await sleep(1500); // Display "!" for 1.5 seconds

                // 3. Post-flash
                await flashText('DATA..', 'crimson', 'red', 400);

                // 4. Fade out "!"
                exclamation.style.opacity = '0';
                await sleep(500); // Wait for fade out
                if (document.body.contains(exclamation)) {
                    document.body.removeChild(exclamation);
                }

            } catch (err) {
                console.error('Easter egg failed:', err);
            }
        }
    };
    
    const resetIdleTimer = () => {
        if (easterEggHasRun) return;
        clearTimeout(idleTimer);
        idleTimer = setTimeout(runEasterEgg, 1000); // 1-second idle timeout
    };

    // Setup initial listeners
    window.addEventListener('mousemove', resetIdleTimer);
    window.addEventListener('keydown', resetIdleTimer);
    window.addEventListener('scroll', resetIdleTimer);
    window.addEventListener('click', resetIdleTimer);

    // Start the first timer
    resetIdleTimer();

    // --- Preset Dropdown Logic ---
    const presetToggleBtn = document.getElementById('preset-toggle-btn');
    const presetDropdownContainer = document.getElementById('preset-dropdown-container');

    presetToggleBtn.addEventListener('click', () => {
        // We check display property because height can be 0 during transition
        const isCurrentlyVisible = presetDropdownContainer.style.display === 'flex';

        if (isCurrentlyVisible) {
            // --- CLOSE THE DROPDOWN ---
            presetDropdownContainer.style.height = '0px';
            presetDropdownContainer.style.opacity = '0';
            currentPresetDisplay.style.display = 'none'; // Hide the preset name
            presetToggleBtn.textContent = 'Show Presets';
            // After the transition, set display to none so it doesn't occupy space
            setTimeout(() => {
                presetDropdownContainer.style.display = 'none';
            }, 400); // This should match the CSS transition duration
        } else {
            // --- OPEN THE DROPDOWN ---
            presetDropdownContainer.style.display = 'flex'; // Make it part of the layout
            presetToggleBtn.textContent = 'Hide Presets';

            // Force a browser reflow. Accessing an element's `offsetHeight` is a reliable way to do this.
            // This ensures the browser processes the `display: 'flex'` change before applying the next style changes for the transition.
            void presetDropdownContainer.offsetHeight;

            presetDropdownContainer.style.height = '95px'; // Set to desired height
            presetDropdownContainer.style.opacity = '1';
            updatePresetDropdown(); // Call this to check if the display should be shown
        }
    });

});
// 006-glitch-canvas.js 
// Preset system for glitch canvas UI (Double OH Six style) 
const PRESET_STORAGE_KEY = 'glitchCanvasPresets_v2';

// Elements 
const presetDropdown = document.querySelector('.preset-dropdown'); 
const presetNameInput = document.querySelector('.preset-name-input'); 
const presetSaveBtn = document.querySelector('.preset-save-btn');
const presetDeleteBtn = document.querySelector('.preset-delete-btn'); // New delete button
const presetDeleteAllBtn = document.querySelector('.preset-delete-all-btn');
const presetNavLeft = document.querySelector('.preset-nav-btn.left'); 
const presetNavRight = document.querySelector('.preset-nav-btn.right'); 
const currentPresetDisplay = document.getElementById('current-preset-display');

// In-memory state
let presets = []; 
let currentPresetIndex = -1; 
let lastPresetChangeTime = 0;
const PRESET_CHANGE_DEBOUNCE = 250; // 0.25 seconds

// --- Core Preset Logic ---

function loadPresetsFromStorage() {
  try {
    const storedPresets = localStorage.getItem(PRESET_STORAGE_KEY);
    if (storedPresets) {
      presets = JSON.parse(storedPresets);
      currentPresetIndex = -1; // Start with no preset selected
    } else {
      presets = []; // Initialize if nothing is in storage
    }
  } catch (e) {
    console.error("Failed to load presets from localStorage", e);
    presets = [];
  }
  updatePresetDropdown();
}

function savePresetsToStorage() {
  try {
    localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
  } catch (e) {
    console.error("Failed to save presets to localStorage", e);
  }
}

// Utility: Update the dropdown and display with current presets 
function updatePresetDropdown() { 
  presetDropdown.innerHTML = '';
  // Add a placeholder option
  const placeholder = document.createElement('option');
  placeholder.value = -1;
  placeholder.textContent = 'Select a Preset...';
  presetDropdown.appendChild(placeholder);

  presets.forEach((preset, idx) => { 
    const opt = document.createElement('option'); 
    opt.value = idx; 
    opt.textContent = preset.name; 
    presetDropdown.appendChild(opt); 
  }); 

  presetDropdown.value = currentPresetIndex; 

  if (currentPresetIndex >= 0 && presets[currentPresetIndex]) {
    currentPresetDisplay.textContent = `[ ${presets[currentPresetIndex].name} ]`;
    currentPresetDisplay.style.display = 'block'; // Always show if a preset is loaded
  } else {
    currentPresetDisplay.textContent = '[DEBUG TEXT]';
    // Only hide if the dropdown is also closed
    const isDropdownOpen = presetDropdownContainer.style.display === 'flex';
    currentPresetDisplay.style.display = isDropdownOpen ? 'block' : 'none';
  }
}
 
// Save current settings as a new or updated preset 
presetSaveBtn.addEventListener('click', () => { 
  const name = presetNameInput.value.trim(); 
  if (!name) {
    alert("Please enter a name for the preset.");
    return;
  }

  const settings = getCurrentEffectSettings(); 
  
  // Check if a preset with this name already exists
  const existingIndex = presets.findIndex(p => p.name === name);

  if (existingIndex > -1) {
    // Update existing preset
    if (confirm(`A preset named "${name}" already exists. Overwrite it?`)) {
        presets[existingIndex].settings = settings;
        currentPresetIndex = existingIndex;
    } else {
        return; // User cancelled overwrite
    }
  } else {
    // Add new preset
    presets.push({ name, settings }); 
    currentPresetIndex = presets.length - 1; 
  }
  
  savePresetsToStorage();
  updatePresetDropdown(); 
  // Don't clear the input, so it's easy to save again
}); 

// Delete the currently selected preset
presetDeleteBtn.addEventListener('click', () => {
  if (currentPresetIndex < 0 || presets.length === 0) {
    alert("No preset selected to delete.");
    return;
  }

  if (confirm(`Are you sure you want to delete the preset "${presets[currentPresetIndex].name}"?`)) {
    presets.splice(currentPresetIndex, 1);
    currentPresetIndex = -1; // Reset selection
    presetNameInput.value = '';
    savePresetsToStorage();
    updatePresetDropdown();
    // Maybe apply default settings or do nothing
  }
});

// Delete all presets
presetDeleteAllBtn.addEventListener('click', () => {
  if (presets.length === 0) {
    alert("There are no presets to delete.");
    return;
  }

  if (confirm("Are you sure you want to delete ALL presets? This action cannot be undone.")) {
    presets = [];
    currentPresetIndex = -1;
    presetNameInput.value = '';
    savePresetsToStorage();
    updatePresetDropdown();
  }
});
 
// Load a preset when selected from dropdown 
presetDropdown.addEventListener('change', () => { 
  const now = Date.now();
  if (now - lastPresetChangeTime < PRESET_CHANGE_DEBOUNCE) {
    presetDropdown.value = currentPresetIndex; // Revert UI
    return;
  }
  lastPresetChangeTime = now;

  const idx = parseInt(presetDropdown.value, 10); 
  if (idx > -1 && presets[idx]) { 
    currentPresetIndex = idx; 
    applyEffectSettings(presets[idx].settings); 
    presetNameInput.value = presets[idx].name; // Populate name input for easy overwriting
  } else {
    currentPresetIndex = -1;
    presetNameInput.value = '';
  }
  updatePresetDropdown(); // Update display
}); 
 
// Cycle left 
presetNavLeft.addEventListener('click', () => { 
  const now = Date.now();
  if (now - lastPresetChangeTime < PRESET_CHANGE_DEBOUNCE) return;
  lastPresetChangeTime = now;

  if (presets.length === 0) return; 
  currentPresetIndex = (currentPresetIndex - 1 + presets.length) % presets.length; 
  presetDropdown.value = currentPresetIndex; 
  applyEffectSettings(presets[currentPresetIndex].settings); 
  presetNameInput.value = presets[currentPresetIndex].name;
  updatePresetDropdown(); // Update display
}); 
 
// Cycle right 
presetNavRight.addEventListener('click', () => { 
  const now = Date.now();
  if (now - lastPresetChangeTime < PRESET_CHANGE_DEBOUNCE) return;
  lastPresetChangeTime = now;

  if (presets.length === 0) return; 
  currentPresetIndex = (currentPresetIndex + 1) % presets.length; 
  presetDropdown.value = currentPresetIndex; 
  applyEffectSettings(presets[currentPresetIndex].settings); 
  presetNameInput.value = presets[currentPresetIndex].name;
  updatePresetDropdown(); // Update display
}); 
 
// Helpers (replace with your actual effect logic) 
function getCurrentEffectSettings() {
  const settings = {
    masterOpacity: masterOpacity,
    effects: { ...effectAlphas },
    isAutoGlitching: isAutoGlitching,
    isContinuallyRandomizing: isContinuallyRandomizing,
    sliderLocks: { ...sliderLocks }
  };
  return settings;
} 

function applyEffectSettings(settings) {
  if (!settings) return;

  masterOpacity = settings.masterOpacity ?? 1.0;
  globalSlider.value = masterOpacity;

  // Apply preset settings
  if (settings.effects) {
      for (const key in settings.effects) {
          if (effectAlphas.hasOwnProperty(key)) {
              effectAlphas[key] = settings.effects[key];
          }
      }
  }

  // Restore button states
  isAutoGlitching = settings.isAutoGlitching ?? false;
  autoGlitchBtn.textContent = isAutoGlitching ? 'Auto Glitch: ON' : 'Auto Glitch: OFF';
  persistentAutoGlitchLoop(); // Apply the change

  isContinuallyRandomizing = settings.isContinuallyRandomizing ?? false;
  continualRandomizeBtn.textContent = isContinuallyRandomizing ? 'Continual Randomization: ON' : 'Continual Randomization: OFF';
  if (isContinuallyRandomizing) {
    generateNewRandomTargets(); // Start randomization if enabled
  }

  // Restore slider lock states
  if (settings.sliderLocks) {
    Object.keys(sliderLocks).forEach(name => {
      const isLocked = settings.sliderLocks[name] ?? false;
      sliderLocks[name] = isLocked;
      const lockButton = sliderElements[name]?.parentElement.querySelector('.lock-button');
      if (lockButton) {
        lockButton.classList.toggle('locked', isLocked);
        lockButton.textContent = isLocked ? '[LOCKED!]' : '<LOCK!>';
      }
    });
  }

  // Update all slider UI elements to reflect the newly loaded preset
  Object.keys(sliderElements).forEach(name => {
      if (sliderElements[name] && effectAlphas.hasOwnProperty(name)) {
          sliderElements[name].value = effectAlphas[name];
      }
  });
} 

// Initial Load
document.addEventListener('DOMContentLoaded', loadPresetsFromStorage); 
</script>
</body>
</html>
    presetNameInput.value = presets[idx].name; // Populate name input for easy overwriting
  } else {
    currentPresetIndex = -1;
    presetNameInput.value = '';
  }
  updatePresetDropdown(); // Update display
}); 
 
// Cycle left 
presetNavLeft.addEventListener('click', () => { 
  const now = Date.now();
  if (now - lastPresetChangeTime < PRESET_CHANGE_DEBOUNCE) return;
  lastPresetChangeTime = now;

  if (presets.length === 0) return; 
  currentPresetIndex = (currentPresetIndex - 1 + presets.length) % presets.length; 
  presetDropdown.value = currentPresetIndex; 
  applyEffectSettings(presets[currentPresetIndex].settings); 
  presetNameInput.value = presets[currentPresetIndex].name;
  updatePresetDropdown(); // Update display
}); 
 
// Cycle right 
presetNavRight.addEventListener('click', () => { 
  const now = Date.now();
  if (now - lastPresetChangeTime < PRESET_CHANGE_DEBOUNCE) return;
  lastPresetChangeTime = now;

  if (presets.length === 0) return; 
  currentPresetIndex = (currentPresetIndex + 1) % presets.length; 
  presetDropdown.value = currentPresetIndex; 
  applyEffectSettings(presets[currentPresetIndex].settings); 
  presetNameInput.value = presets[currentPresetIndex].name;
  updatePresetDropdown(); // Update display
}); 
 
// Helpers (replace with your actual effect logic) 
function getCurrentEffectSettings() {
  const settings = {
    masterOpacity: masterOpacity,
    effects: { ...effectAlphas },
    isAutoGlitching: isAutoGlitching,
    isContinuallyRandomizing: isContinuallyRandomizing,
    sliderLocks: { ...sliderLocks }
  };
  return settings;
} 

function applyEffectSettings(settings) {
  if (!settings) return;

  masterOpacity = settings.masterOpacity ?? 1.0;
  globalSlider.value = masterOpacity;

  // Apply preset settings
  if (settings.effects) {
      for (const key in settings.effects) {
          if (effectAlphas.hasOwnProperty(key)) {
              effectAlphas[key] = settings.effects[key];
          }
      }
  }

  // Restore button states
  isAutoGlitching = settings.isAutoGlitching ?? false;
  autoGlitchBtn.textContent = isAutoGlitching ? 'Auto Glitch: ON' : 'Auto Glitch: OFF';
  persistentAutoGlitchLoop(); // Apply the change

  isContinuallyRandomizing = settings.isContinuallyRandomizing ?? false;
  continualRandomizeBtn.textContent = isContinuallyRandomizing ? 'Continual Randomization: ON' : 'Continual Randomization: OFF';
  if (isContinuallyRandomizing) {
    generateNewRandomTargets(); // Start randomization if enabled
  }

  // Restore slider lock states
  if (settings.sliderLocks) {
    Object.keys(sliderLocks).forEach(name => {
      const isLocked = settings.sliderLocks[name] ?? false;
      sliderLocks[name] = isLocked;
      const lockButton = sliderElements[name]?.parentElement.querySelector('.lock-button');
      if (lockButton) {
        lockButton.classList.toggle('locked', isLocked);
        lockButton.textContent = isLocked ? '[LOCKED!]' : '<LOCK!>';
      }
    });
  }

  // Update all slider UI elements to reflect the newly loaded preset
  Object.keys(sliderElements).forEach(name => {
      if (sliderElements[name] && effectAlphas.hasOwnProperty(name)) {
          sliderElements[name].value = effectAlphas[name];
      }
  });
} 

// Initial Load
document.addEventListener('DOMContentLoaded', loadPresetsFromStorage); 
</script>
</body>
</html>
